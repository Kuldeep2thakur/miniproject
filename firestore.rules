/**
 * @fileoverview Firestore Security Rules for the WanderLust application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user profiles and their associated trips and entries.
 * Public readability is supported for trips explicitly marked as public. Shared trips are accessible to specified users.
 * Routes and Comments are secured based on the visibility of their parent Trips and Entries respectively.
 *
 * Data Structure:
 * - /users/{userId}: User profiles, accessible only to the authenticated user.
 * - /users/{userId}/trips/{tripId}: Trips owned by a specific user.
 * - /users/{userId}/trips/{tripId}/entries/{entryId}: Entries for a specific trip.
 * - /routes/{routeId}: Route data, associated with a specific trip via the `tripId` field.
 * - /comments/{commentId}: Comments, associated with a specific entry via the `entryId` and `authorId` fields.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profiles.
 * - Trips are owned by a user and can be private, public, or shared.
 * - Entries inherit the security settings of their parent trip.
 * - Routes are secured based on the ownership of their parent trip.
 * - Comments are secured based on the visibility of their parent entries.
 * - Listing all users is disallowed.
 *
 * Denormalization for Authorization:
 * - The `Trip` document includes `visibility` and `sharedWith` fields to enable authorization without requiring `get()` calls to other documents.
 *   This enables rules to quickly determine if a user has permission to read a trip.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profiles. Only the authenticated user can read/write their own profile.
     * @path /users/{userId}
     * @allow (get, update, delete) if request.auth.uid == userId
     * @allow (create) if request.auth.uid == request.resource.data.id
     * @deny (list)
     * @deny (create) if request.auth.uid != request.resource.data.id
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;

      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Secure trip information owned by a specific user. Includes denormalized 'visibility' and 'sharedWith' for authorization independence.
     * @path /users/{userId}/trips/{tripId}
     * @allow (get, list) if resource.data.visibility == 'public' || isOwner(userId) || (resource.data.visibility == 'shared' && resource.data.sharedWith.hasAny([request.auth.uid]))
     * @allow (create) if isOwner(userId)
     * @allow (update, delete) if isExistingOwner(userId)
     * @deny (create) if !isOwner(userId)
     * @principle Enforces document ownership for writes, public read for public trips, shared read for shared trips.
     */
    match /users/{userId}/trips/{tripId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if resource.data.get("visibility", "") == 'public' || isOwner(userId) || (resource.data.get("visibility", "") == 'shared' && resource.data.sharedWith.hasAny([request.auth.uid]));

      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Secure trip entries for a specific trip. Authorization is based on the parent trip's ownership and visibility.
     * @path /users/{userId}/trips/{tripId}/entries/{entryId}
     * @allow (get, list) if get(/databases/$(database)/documents/users/$(userId)/trips/$(tripId)).data.visibility == 'public' || isTripOwner(userId, tripId) || isTripShared(userId, tripId)
     * @allow (create) if isTripOwner(userId, tripId)
     * @allow (update, delete) if isExistingTripOwner(userId, tripId)
     * @deny (create) if !isTripOwner(userId, tripId)
     * @principle Enforces document ownership inherited from the trip for writes, public read for public trips, shared read for shared trips.
     */
    match /users/{userId}/trips/{tripId}/entries/{entryId} {
        function getTrip() {
            return get(/databases/$(database)/documents/users/$(userId)/trips/$(tripId));
        }

        function isTripOwner() {
          return getTrip().data.get("ownerId", "") == request.auth.uid;
        }

        function isTripShared() {
          return getTrip().data.sharedWith.hasAny([request.auth.uid]);
        }

        function isTripPublic() {
          return getTrip().data.get("visibility", "") == 'public';
        }

        function isSignedIn() {
          return request.auth != null;
        }

        allow get, list: if isTripPublic() || isTripOwner() || isTripShared();

        allow create: if isSignedIn() && isTripOwner();
        allow update: if isTripOwner();
        allow delete: if isTripOwner();
      }

    /**
     * @description Secure route data associated with a specific trip.
     * @path /routes/{routeId}
     * @allow (get, list) if isTripPublicByRouteId(resource.data.tripId) || isTripOwnerByRouteId(resource.data.tripId) || isTripSharedByRouteId(resource.data.tripId)
     * @allow (create) if isTripOwnerByRouteId(request.resource.data.tripId)
     * @allow (update, delete) if isExistingTripOwnerByRouteId(resource.data.tripId)
     * @principle Enforces document ownership inherited from the trip for writes, public read for public trips, shared read for shared trips.
     */
    match /routes/{routeId} {
      function getTrip(tripId) {
        return get(/databases/$(database)/documents/users/{userId}/trips/$(tripId));
      }

      function isTripOwnerByRouteId(tripId) {
        return getTrip(tripId).data.get("ownerId", "") == request.auth.uid;
      }

      function isTripSharedByRouteId(tripId) {
        return getTrip(tripId).data.sharedWith.hasAny([request.auth.uid]);
      }

      function isTripPublicByRouteId(tripId) {
        return getTrip(tripId).data.get("visibility", "") == 'public';
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if resource.data.get("tripId", "") != null && (isTripPublicByRouteId(resource.data.tripId) || isTripOwnerByRouteId(resource.data.tripId) || isTripSharedByRouteId(resource.data.tripId));

      allow create: if isSignedIn() && isTripOwnerByRouteId(request.resource.data.tripId);
      allow update: if isSignedIn() && isTripOwnerByRouteId(resource.data.tripId);
      allow delete: if isSignedIn() && isTripOwnerByRouteId(resource.data.tripId);
    }

    /**
     * @description Secure comments on trip entries.
     * @path /comments/{commentId}
     * @allow (get, list) if isEntryPublicByCommentId(resource.data.entryId) || isEntryOwnerByCommentId(resource.data.entryId) || isEntrySharedByCommentId(resource.data.entryId) || request.auth.uid == resource.data.authorId
     * @allow (create) if isSignedIn()
     * @allow (update, delete) if isExistingCommentOwner(resource.data.authorId)
     * @principle Public read for comments on public entries, owner read/write for comment authors.
     */
    match /comments/{commentId} {
      function getEntry(entryId) {
          return get(/databases/$(database)/documents/users/{userId}/trips/{tripId}/entries/$(entryId));
      }

      function isEntryOwnerByCommentId(entryId) {
        return getEntry(entryId).data.get("ownerId", "") == request.auth.uid;
      }

      function isEntrySharedByCommentId(entryId) {
        return getEntry(entryId).data.sharedWith.hasAny([request.auth.uid]);
      }

      function isEntryPublicByCommentId(entryId) {
        return getEntry(entryId).data.get("visibility", "") == 'public';
      }

      function isCommentOwner(authorId) {
        return request.auth.uid == authorId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if resource.data.get("entryId", "") != null && (isEntryPublicByCommentId(resource.data.entryId) || isEntryOwnerByCommentId(resource.data.entryId) || isEntrySharedByCommentId(resource.data.entryId) || isCommentOwner(resource.data.authorId));
      allow create: if isSignedIn();
      allow update: if isSignedIn() && isCommentOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isCommentOwner(resource.data.authorId);
    }
  }
}